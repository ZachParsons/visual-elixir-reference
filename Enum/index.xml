<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Enum on Visual Elixir Reference</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/</link><description>Recent content in Enum on Visual Elixir Reference</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://superruzafa.github.io/visual-elixir-reference/Enum/index.xml" rel="self" type="application/rss+xml"/><item><title>all?/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/all_/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/all_/2/</guid><description>Enum.all?/2 defmodule Enum do def all?(enumerable, fun \\ fn x -&amp;gt; x end) end Returns true if all the elements in enumerable evaluate to a truthy value when the function fun is applied over them.
As soon as one element evaluates to a falsy value, the iteration stops and the whole function returns false.
On empty enumerables this function returns true.</description></item><item><title>any?/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/any_/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/any_/2/</guid><description>Enum.any?/2 defmodule Enum do def any?(enumerable, fun \\ fn x -&amp;gt; x end) end Returns true if at least one element in enumerable evaluates to a truthy value when the function fun is applied over it.
If no element in enumerable evaluates to a truthy value then the function returns false.
On empty enumerables this function returns false.</description></item><item><title>at/3</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/at/3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/at/3/</guid><description>Enum.at/3 defmodule Enum do def at(enumerable, index, default \\ nil) end Finds the element in enumerable at the index index (zero-based).
A negative index can be passed, which means the index is counted from the end.
The function evaluates to default if the index is out of bounds.</description></item><item><title>chunk_by/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/chunk_by/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/chunk_by/2/</guid><description>Enum.chunk_by/2 defmodule Enum do def chunk_by(enumerable, fun) end Splits enumerable on every element for which fun returns a new value.</description></item><item><title>chunk_every/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/chunk_every/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/chunk_every/2/</guid><description>Enum.chunk_every/2 defmodule Enum do def chunk_every(enumerable, count) end Returns a list of lists containing count elements each.
The last chunk may content count or less elements.</description></item><item><title>chunk_every/4</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/chunk_every/4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/chunk_every/4/</guid><description>Enum.chunk_every/4 defmodule Enum do def chunk_every(enumerable, count, step, leftover \\ []) end Returns list of lists containing count elements each, where each new chunk starts step elements into enumerable.
step is optional and, if not passed, defaults to count, i.e. chunks do not overlap.
If the last chunk does not have count elements to fill the chunk, elements are taken from leftover to fill in the chunk. If leftover does not have enough elements to fill the chunk, then a partial chunk is returned with less than count elements.</description></item><item><title>chunk_while/4</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/chunk_while/4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/chunk_while/4/</guid><description>Enum.chunk_while/4 defmodule Enum do def chunk_while(enumerable, acc, chunk_fun, after_fun) end Chunks enumerable with fine grained control when every chunk is emitted.
chunk_fun receives the current element and the accumulator and must return
{:cont, chunk, acc} to emit the given chunk and continue with accumulator or {:cont, acc} to not emit any chunk and continue with the return accumulator. after_fun is invoked when iteration is done and must also return {:cont, chunk, acc} or {:cont, acc}.</description></item><item><title>concat/1</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/concat/1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/concat/1/</guid><description>Enum.concat/1 defmodule Enum do def concat(enumerables) end Given an enumerable of enumerables, concatenates enumerables into a single list.</description></item><item><title>concat/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/concat/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/concat/2/</guid><description>Enum.concat/2 defmodule Enum do def concat(left, right) end Concatenates the enumerable on the left with the enumerable on the right.</description></item><item><title>count/1</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/count/1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/count/1/</guid><description>Enum.count/1 defmodule Enum do def count(enumerable) end Returns the size of the enumerable.</description></item><item><title>count/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/count/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/count/2/</guid><description>Enum.count/2 defmodule Enum do def count(enumerable, fun) end Returns the count of elements in enumerable for which fun returns a truthy value.</description></item><item><title>dedup/1</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/dedup/1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/dedup/1/</guid><description>Enum.dedup/1 defmodule Enum do def dedup(enumerable) end Discards all those adjacent duplicated elements in the enumerable, collapsing them in a single element.</description></item><item><title>dedup_by/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/dedup_by/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/dedup_by/2/</guid><description>Enum.dedup_by/2 defmodule Enum do def dedup_by(enumerable, fun) end Discards all those adjacent elements in enumerable which are duplicated in terms of the output of the fun function, collapsing them in a single element.</description></item><item><title>drop/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/drop/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/drop/2/</guid><description>Enum.drop/2 defmodule Enum do def drop(enumerable, count) end Drops count elements from the enumerable.
If a negative count is given, the count last values will be dropped.</description></item><item><title>drop_every/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/drop_every/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/drop_every/2/</guid><description>Enum.drop_every/2 defmodule Enum do def drop_every(enumerable, nth) end Returns a list where every nth element in enumerable has been dropped, starting with the first element.
The first element is always dropped, unless nth is 0.
The second argument specifying every nth element must be a non-negative integer.</description></item><item><title>drop_while/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/drop_while/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/drop_while/2/</guid><description>Enum.drop_while/2 defmodule Enum do def drop_while(enumerable, fun) end Drops elements at the beginning of the enumerable while fun returns a truthy value.</description></item><item><title>each/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/each/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/each/2/</guid><description>Enum.each/2 defmodule Enum do def each(enumerable, fun) end Invokes the given fun for each element in the enumerable and returns :ok.</description></item><item><title>empty?/1</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/empty/1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/empty/1/</guid><description>Enum.empty?/1 defmodule Enum do def empty?(enumerable) end Returns true if the enumerable is empty.
Otherwise it returns false.</description></item><item><title>fetch!/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/fetch_/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/fetch_/2/</guid><description>Enum.fetch!/2 defmodule Enum do def fetch!(enumerable, index) end Finds the element at the given index (zero-based) and returns {:ok, element} if found.
A negative index can be passed, which means the index is counted from the end.
Raises OutOfBoundsError if the given index is outside the range of the enumerable.</description></item><item><title>fetch/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/fetch/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/fetch/2/</guid><description>Enum.fetch/2 defmodule Enum do def fetch(enumerable, index) end Finds the element at the given index (zero-based) and returns {:ok, element} if found.
A negative index can be passed, which means the index is counted from the end.
Returns :error if the given index is outside the range of the enumerable.</description></item><item><title>filter/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/filter/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/filter/2/</guid><description>Enum.filter/2 defmodule Enum do def filter(enumerable, fun) end Returns only those elements for which fun returns a truthy value.</description></item><item><title>find/3</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/find/3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/find/3/</guid><description>Enum.find/3 defmodule Enum do def find(enumerable, default \\ nil, fun) end Returns the first element for which fun returns a truthy value.
If no such element is found it returns default.</description></item><item><title>find_index/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/find_index/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/find_index/2/</guid><description>Enum.find_index/2 defmodule Enum do def find_index(enumerable, fun) end Returns the index (zero-based) of the first element for which fun returns a truthy value.
If no such element is found it returns nil.</description></item><item><title>find_value/3</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/find_value/3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/find_value/3/</guid><description>Enum.find_value/3 defmodule Enum do def find_value(enumerable, default \\ nil, fun) end Returns the value of the first invocation of the function fun which returns a truthy value.
If no such element is found it returns default.</description></item><item><title>flat_map/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/flat_map/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/flat_map/2/</guid><description>Enum.flat_map/2 defmodule Enum do def flat_map(enumerable, fun) end Maps the given fun over enumerable and flattens the result.</description></item><item><title>flat_map_reduce/3</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/flat_map_reduce/3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/flat_map_reduce/3/</guid><description>Enum.flat_map_reduce/3 defmodule Enum do def flat_map_reduce(enumerable, acc, fun) end Maps and reduces an enumerable, flattening the given results (only one level deep).
It expects an accumulator acc and a function fun that receives each enumerable element, and must return a tuple containing a new enumerable (often a list) with the new accumulator.
The map-reducing may end before processing all the enumerable if the fun function returns a tuple with :halt as first element and the accumulator as second.</description></item><item><title>frequencies/1</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/frequencies/1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/frequencies/1/</guid><description>Enum.frequencies/1 defmodule Enum do def frequencies(enumerable) end Returns a map with keys as unique elements of enumerable and values as the count of every element.</description></item><item><title>frequencies_by/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/frequencies_by/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/frequencies_by/2/</guid><description>Enum.frequencies_by/2 defmodule Enum do def frequencies_by(enumerable, fun) end Returns a map with keys as unique elements given by fun and values as the count of every element.</description></item><item><title>group_by/3</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/group_by/3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/group_by/3/</guid><description>Enum.group_by/3 defmodule Enum do def group_by(enumerable, key_fun, val_fun \\ fn x -&amp;gt; x end) end Splits the enumerable into groups based on key_fun.
The result is a map where each key is given by key_fun and each value is a list of elements given by value_fun. The order of elements within each list is preserved from the enumerable. However, like all maps, the resulting map is unordered.</description></item><item><title>intersperse/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/intersperse/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/intersperse/2/</guid><description>Enum.intersperse/2 defmodule Enum do def intersperse(enumerable, elem) end Intersperses elem between each element of enumerable.</description></item><item><title>join/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/join/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/join/2/</guid><description>Enum.join/2 defmodule Enum do def join(enumerable, joiner \\ &amp;#34;&amp;#34;) end Joins the given enumerable into a binary using joiner as a separator.
If joiner is not passed at all, it defaults to the empty binary.
All elements in the enumerable must be convertible to a binary, otherwise an error is raised.</description></item><item><title>map/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/map/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/map/2/</guid><description>Enum.map/2 defmodule Enum do def map(enumerable, fun) end Returns a list where each element is the result of invoking fun on each corresponding element of enumerable.</description></item><item><title>map_every/3</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/map_every/3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/map_every/3/</guid><description>Enum.map_every/3 defmodule Enum do def map_every(enumerable, nth, fun) end Returns a list of results of invoking fun on every nth element of enumerable, starting with the first element.
The first element is always passed to the given function, unless nth is 0.
The second argument specifying every nth element must be a non-negative integer.
If nth is 0, then enumerable is directly converted to a list, without fun being ever applied.</description></item><item><title>map_intersperse/3</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/map_intersperse/3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/map_intersperse/3/</guid><description>Enum.map_intersperse/3 defmodule Enum do def map_intersperse(enumerable, elem, fun) end Maps with the function fun and intersperses the given enumerable in one pass.</description></item><item><title>map_join/3</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/map_join/3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/map_join/3/</guid><description>Enum.map_join/3 defmodule Enum do def map_join(enumerable, joiner \\ &amp;#34;&amp;#34;, fun) end Maps and joins the given enumerable in one pass.
joiner can be either a binary or a list and the result will be of the same type as joiner. If joiner is not passed at all, it defaults to an empty binary.
All elements returned from invoking the fun must be convertible to a binary, otherwise an error is raised.</description></item><item><title>map_reduce/3</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/map_reduce/3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/map_reduce/3/</guid><description>Enum.map_reduce/3 defmodule Enum do def map_reduce(enumerable, acc, fun) end Invokes the given function to each element in the enumerable to reduce it to a single element, while keeping an accumulator.
Returns a tuple where the first element is the mapped enumerable and the second one is the final accumulator.
The function, fun, receives two arguments: the first one is the element, and the second one is the accumulator. fun must return a tuple with two elements in the form of {result, accumulator}.</description></item><item><title>max/3</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/max/3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/max/3/</guid><description>Enum.max/3 defmodule Enum do def max( enumerable, sorter \\ &amp;amp;&amp;gt;=/2, empty_fallback \\ fn -&amp;gt; raise(Enum.EmptyError) end ) end Returns the maximal element in the enumerable according to Erlang&amp;rsquo;s term ordering.
By default, the comparison is done with the &amp;gt;= sorter function. If multiple elements are considered maximal, the first one that was found is returned.
If the enumerable is empty, the provided empty_fallback is called.
The default empty_fallback raises Enum.</description></item><item><title>max_by/4</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/max_by/4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/max_by/4/</guid><description>Enum.max_by/4 defmodule Enum do def max_by( enumerable, fun, sorter \\ &amp;amp;&amp;gt;=/2, empty_fallback \\ fn -&amp;gt; raise(Enum.EmptyError) end) ) end Returns the maximal element in the enumerable as calculated by the given fun.
By default, the comparison is done with the &amp;gt;= sorter function. If multiple elements are considered maximal, the first one that was found is returned.
If the enumerable is empty, the provided empty_fallback is called.
The default empty_fallback raises Enum.</description></item><item><title>member?/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/member/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/member/2/</guid><description>Enum.member?/2 defmodule Enum do def member?(enumerable, elem) end Returns true if any element in the enumerable is equal (in terms of ===/3) to elem.
If no element is found then false is returned.</description></item><item><title>min/3</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/min/3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/min/3/</guid><description>Enum.min/3 defmodule Enum do def min( enumerable, sorter \\ &amp;amp;&amp;lt;=/2, empty_fallback \\ fn -&amp;gt; raise(Enum.EmptyError) end ) end Returns the minimal element in the enumerable according to Erlang&amp;rsquo;s term ordering.
By default, the comparison is done with the &amp;lt;= sorter function. If multiple elements are considered minimal, the first one that was found is returned.
If the enumerable is empty, the provided empty_fallback is called.
The default empty_fallback raises Enum.</description></item><item><title>min_by/4</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/min_by/4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/min_by/4/</guid><description>Enum.min_by/4 defmodule Enum do def min_by( enumerable, fun, sorter \\ &amp;amp;&amp;lt;=/2, empty_fallback \\ fn -&amp;gt; raise(Enum.EmptyError) end) ) end Returns the minimal element in the enumerable as calculated by the given fun.
By default, the comparison is done with the &amp;lt;= sorter function. If multiple elements are considered minimal, the first one that was found is returned.
If the enumerable is empty, the provided empty_fallback is called.
The default empty_fallback raises Enum.</description></item><item><title>min_max/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/min_max/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/min_max/2/</guid><description>Enum.min_max/2 defmodule Enum do def min_max( enumerable, empty_fallback \\ fn -&amp;gt; raise(Enum.EmptyError) end ) end Returns a tuple with the minimal and the maximal elements in the enumerable according to Erlang&amp;rsquo;s term ordering. If multiple elements are considered maximal or minimal, the first one that was found is returned.
If the enumerable is empty, the provided empty_fallback is called.
The default empty_fallback raises Enum.EmptyError.</description></item><item><title>min_max_by/3</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/min_max_by/3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/min_max_by/3/</guid><description>Enum.min_max_by/3 defmodule Enum do def min_max( enumerable, fun, empty_fallback \\ fn -&amp;gt; raise(Enum.EmptyError) end ) end Returns a tuple with the minimal and the maximal elements in the enumerable as calculated by the given function. If multiple elements are considered maximal or minimal, the first one that was found is returned.
If the enumerable is empty, the provided empty_fallback is called.
The default empty_fallback raises Enum.EmptyError.</description></item><item><title>random/1</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/random/1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/random/1/</guid><description>Enum.random/1 defmodule Enum do def random(enumerable) end Returns a random element from enumerable.
This function uses Erlang&amp;rsquo;s :rand module to calculate the random value. Check its documentation for setting a different random algorithm or a different seed.
The implementation is based on the reservoir sampling algorithm. It assumes that the sample being returned can fit into memory; the input enumerable doesn&amp;rsquo;t have to, as it is traversed just once.</description></item><item><title>reduce/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/reduce/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/reduce/2/</guid><description>Enum.reduce/2 defmodule Enum do def reduce(enumerable, fun) end Invokes fun for each element in the enumerable with the accumulator.
The first element of the enumerable is used as the initial value of the accumulator. Then the function is invoked with the next element and the accumulator. The result returned by the function is used as the accumulator for the next iteration, recursively. When the enumerable is done, the last accumulator is returned.</description></item><item><title>reduce/3</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/reduce/3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/reduce/3/</guid><description>Enum.reduce/3 defmodule Enum do def reduce(enumerable, acc, fun) end Invokes fun for each element in the enumerable with the accumulator.
The initial value of the accumulator is acc. The function is invoked for each element in the enumerable with the accumulator. The result returned by the function is used as the accumulator for the next iteration. The function returns the last accumulator.
It returns acc if enumerable is empty.</description></item><item><title>reduce_while/3</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/reduce_while/3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/reduce_while/3/</guid><description>Enum.reduce_while/3 defmodule Enum do def reduce_while(enumerable, acc, fun) end Reduces enumerable until it&amp;rsquo;s exhausted or fun returns {:halt, term}.
The return value for fun is expected to be
{:cont, acc} to continue the reduction with acc as the new accumulator or {:halt, acc} to halt the reduction If fun returns {:halt, acc} the reduction is halted and the function returns acc.
Otherwise, if enumerable is exhausted, the function returns the accumulator of the last {:cont, acc}.</description></item><item><title>reject/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/reject/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/reject/2/</guid><description>Enum.reject/2 defmodule Enum do def reject(enumerable, fun) end Returns only those elements for which fun does not return a truthy value.</description></item><item><title>reverse/1</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/reverse/1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/reverse/1/</guid><description>Enum.reverse/1 defmodule Enum do def reverse(enumerable) end Returns the elements from enumerable in reverse order.</description></item><item><title>reverse/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/reverse/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/reverse/2/</guid><description>Enum.reverse/2 defmodule Enum do def reverse(enumerable, tail) end Returns the elements from enumerable in reverse order and then appends tail to it.</description></item><item><title>reverse_slice/3</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/reverse_slice/3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/reverse_slice/3/</guid><description>Enum.reverse_slice/3 defmodule Enum do def reverse_slice(enumerable, start, count) end Reverses the enumerable in the range from initial start through count elements.</description></item><item><title>scan/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/scan/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/scan/2/</guid><description>Enum.scan/2 defmodule Enum do def scan(enumerable, fun) end Applies the function fun to each element in the enumerable, storing the result in a list and passing it as the accumulator for the next computation. Uses the first element in the enumerable as the starting value.</description></item><item><title>scan/3</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/scan/3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/scan/3/</guid><description>Enum.scan/3 defmodule Enum do def scan(enumerable, acc, fun) end Applies the function fun to each element in the enumerable, storing the result in a list and passing it as the accumulator for the next computation. Uses the given acc as the starting value.</description></item><item><title>shuffle/1</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/shuffle/1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/shuffle/1/</guid><description>Enum.shuffle/1 defmodule Enum do def shuffle(enumerable) end Returns the elements enumerable shuffled.
This function uses Erlang&amp;rsquo;s :rand module to calculate the random value. Check its documentation for setting a different random algorithm or a different seed.</description></item><item><title>slice/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/slice/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/slice/2/</guid><description>Enum.slice/2 defmodule Enum do def slice(enumerable, range) end Returns a subset list of the given enumerable by range.
range must be a Range. Given an enumerable, it drops elements before range.first (zero-base), then takes elements until element range.last (inclusively).
If range.last is out of bounds, then it is assigned as the index of the last element.
Indexes are normalized, meaning that negative indexes will be counted from the end.</description></item><item><title>slice/3</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/slice/3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/slice/3/</guid><description>Enum.slice/3 defmodule Enum do def slice(enumerable, start, count) end Returns a subset list of the given enumerable, from start (zero-based) with count number of elements if available.
A negative start can be passed, which means the enumerable is enumerated once and the index is counted from the end.
It returns [] if count is 0 or if start is out of bounds.</description></item><item><title>sort/1</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/sort/1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/sort/1/</guid><description>Enum.sort/1 defmodule Enum do def sort(enumerable) end Sorts the enumerable according to Erlang&amp;rsquo;s term ordering.</description></item><item><title>sort/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/sort/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/sort/2/</guid><description>Enum.sort/2 defmodule Enum do def sort(enumerable, fun) end Sorts the enumerable. The given function fun should compare two arguments, and return true if the first argument precedes or is in the same place as the second one.</description></item><item><title>sort_by/3</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/sort_by/3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/sort_by/3/</guid><description>Enum.sort_by/3 defmodule Enum do def sort_by(enumerable, mapper, sorter \\ &amp;amp;&amp;lt;=/2) end Sorts the enumerable by mapping each element using the provided mapper function and then sorting the mapped elements using the sorter function, which defaults to Kernel.&amp;lt;=/2.</description></item><item><title>split/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/split/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/split/2/</guid><description>Enum.split/2 defmodule Enum do def split(enumerable, count) end Splits the enumerable into two enumerables, leaving count elements in the first one.
If count is a negative number, it starts counting from the back to the beginning of the enumerable.</description></item><item><title>split_while/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/split_while/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/split_while/2/</guid><description>Enum.split_while/2 defmodule Enum do def split_while(enumerable, fun) end Splits enumerable in two at the position of the element for which fun returns a falsy value (false or nil) for the first time.</description></item><item><title>split_with/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/split_with/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/split_with/2/</guid><description>Enum.split_with/2 defmodule Enum do def split_with(enumerable, fun) end Splits the enumerable in two lists by calling fun with each element in the enumerable as its only argument. Returns a tuple with the first list containing all the elements in enumerable for which applying fun returned a truthy value, and a second list with all the elements for which applying fun returned a falsy value (false or nil).
The elements in both the returned lists are in the same relative order as they were in the original enumerable (if such enumerable was ordered, like a list).</description></item><item><title>sum/1</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/sum/1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/sum/1/</guid><description>Enum.sum/1 defmodule Enum do def sum(enumerable) end Returns the sum of all elements of enumerable.
Raises ArithmeticError if enumerable contains a non-numeric value.</description></item><item><title>take/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/take/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/take/2/</guid><description>Enum.take/2 defmodule Enum do def take(enumerable, count) end Takes count elements from the beginning of enumerable.
If a negative count is given, the elements will be taken from the end.
If count is 0, it returns [].</description></item><item><title>take_every/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/take_every/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/take_every/2/</guid><description>Enum.take_every/2 defmodule Enum do def take_every(enumerable, nth) end Returns a list of every nth element in the enumerable, starting with the first element.
The first element is always included, unless nth is 0.
The second argument specifying every nth element must be a non-negative integer.</description></item><item><title>take_random/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/take_random/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/take_random/2/</guid><description>Enum.take_random/2 defmodule Enum do def take_random(enumerable, count) end Takes at most count random elements from enumerable.</description></item><item><title>take_while/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/take_while/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/take_while/2/</guid><description>Enum.take_while/2 defmodule Enum do def take_while(enumerable, fun) end Takes the elements from the beginning of the enumerable while fun returns a truthy value.</description></item><item><title>uniq/1</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/uniq/1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/uniq/1/</guid><description>Enum.uniq/1 defmodule Enum do def uniq(enumerable) end Removes all duplicated elements.</description></item><item><title>uniq_by/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/uniq_by/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/uniq_by/2/</guid><description>Enum.uniq_by/2 defmodule Enum do def uniq_by(enumerable, fun) end Enumerates the enumerable by removing the elements for which function fun returned duplicate elements.
The function fun maps every element to a term. Two elements are considered duplicates if the return value of fun is equal for both of them.
The first occurrence of each element is kept.</description></item><item><title>unzip/1</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/unzip/1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/unzip/1/</guid><description>Enum.unzip/1 defmodule Enum do def unzip(enumerable) end It takes an enumerable with elements being two-element tuples and returns a tuple with two lists, each of which is formed by the first and second element of each tuple, respectively.
This function fails unless enumerable is or can be converted into a list of tuples with exactly two elements in each tuple.</description></item><item><title>with_index/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/with_index/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/with_index/2/</guid><description>Enum.with_index/2 defmodule Enum do def with_index(enumerable, offset \\ 0) end Returns the enumerable with each element wrapped in a tuple alongside its index.
If an offset is given, we will index from the given offset instead of from zero.</description></item><item><title>zip/1</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/zip/1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/zip/1/</guid><description>Enum.zip/1 defmodule Enum do def zip(enumerables) end Zips corresponding elements from a finite collection of enumerables into one list of tuples.
The zipping finishes as soon as any enumerable in the given collection completes.</description></item><item><title>zip/2</title><link>https://superruzafa.github.io/visual-elixir-reference/Enum/zip/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://superruzafa.github.io/visual-elixir-reference/Enum/zip/2/</guid><description>Enum.zip/2 defmodule Enum do def zip(enumerable1, enumerable2) end Zips corresponding elements from two enumerables, enumerable1 and enumerable2 into one list of tuples.
The zipping finishes as soon as any enumerable completes.</description></item></channel></rss>